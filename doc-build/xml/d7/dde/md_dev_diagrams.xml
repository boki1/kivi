<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="d7/dde/md_dev_diagrams" kind="page">
    <compoundname>md_dev_diagrams</compoundname>
    <title>Details</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Here are some of the details regarding the design and implementation of the kivi compiler.</para>
<para><blockquote><para>Stages of compiling </para>
</blockquote>First, there are 4 major stages involved in the processing of source files.</para>
<para><image type="html" name="https://i.ibb.co/WP7TxWm/Kivi-Compiler-Stages.png" alt="Stages" inline="yes"></image>
</para>
<para><blockquote><para>The what, how and why of the stages </para>
</blockquote>These components form what&apos;s called <emphasis>lexical</emphasis> and <emphasis>syntactical</emphasis> analysis. There key functionalities are to process the given text (marked as &quot;Source File&quot;) and to construct what is called <ulink url="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</ulink>. As it is shown on the schematic, the lexer understands and forms a list of tokens - composed of type (e.g Identifier, Function, etc.) and an associated value. The next step is to transform these lexemes into a tree structure which denotes the order of execution of the individual <emphasis>syntactic structures</emphasis> (e.g expression := number | string literal | etc.). Having taken in account every aspect of the language <emphasis>grammar</emphasis>, the next step is to perform semantic analysis on the tree. Since Kivi does not have any types (only integers) the so-called semantic analysis is pretty-straight forward - are the functions that get called actually defined <ndash/> well that&apos;s not hard :smile:. The intermediate representation component translates the AST generated before in a assembly-looking language which is independent of architecture and easier to translates to actual assembly. Lastly, the intermediate representation get translated to the specified assembly language.</para>
<sect1 id="d7/dde/md_dev_diagrams_1autotoc_md27">
<title>Design</title>
<para><blockquote><para>Syntax analyzer </para>
</blockquote>![UML diagram]()</para>
<para><blockquote><para>Intermediate code generation </para>
</blockquote><bold>TODO: This is going to be added soon :). Stay tuned.</bold> <blockquote><para></para>
</blockquote>![UML diagram]()</para>
<para><blockquote><para>Code generation </para>
</blockquote><bold>TODO: This is going to be added soon :). Stay tuned.</bold></para>
<para>![UML diagram]() <linebreak/>
 </para>
</sect1>
    </detaileddescription>
    <location file="dev/diagrams.md"/>
  </compounddef>
</doxygen>
